

# This file was *autogenerated* from the file /home/maria/signature_function/gaknot/main.sage
from sage.all_cmdline import *   # import sage library

_sage_const_0 = Integer(0); _sage_const_1 = Integer(1); _sage_const_2 = Integer(2); _sage_const_3 = Integer(3); _sage_const_5 = Integer(5); _sage_const_7 = Integer(7); _sage_const_11 = Integer(11); _sage_const_13 = Integer(13); _sage_const_10 = Integer(10)#!/usr/bin/env sage -python

# TBD: read about Factory Method, variable in docstring, sage documentation,
# print calc. to output file
# decide about printing option
# make __main__?

import os
import sys

import itertools as it
import re
import numpy as np
import importlib
from .utility import import_sage
# from . import signature as sig
# from . import cable_signature as cs

package = __name__.split('.')[_sage_const_0 ]
path = os.path.dirname(__file__)
print(path)

sg = import_sage('signature', package='gaknot', path=path)
cs = import_sage('cable_signature', package='gaknot', path=path)




# class Config:
#     def __init__(self):
#         self.f_results = os.path.join(os.getcwd(), "results.out")

class Schemas:


    # knot_formula = "[[k[0],  k[1],  k[2]],\
    #                 [        k[3],  k[4]],\
    #                 [-k[0], -k[3], -k[4]],\
    #                 [       -k[1], -k[2]]]"
    #
    # knot_formula = "[[k[0],   k[1],  k[2]],\
    #                  [               k[3]],\
    #                  [-k[0], -k[1], -k[3]],\
    #                  [              -k[2]]]"


    short_3_layers_a = "[[         k[5],  k[3]], " + \
                        "[        -k[1], -k[3]], " + \
                        "[                k[3]], " + \
                        "[ -k[4], -k[6], -k[3]]]"

    short_3_layers_b = "[[k[4],   k[1],  k[7]], " + \
                        "[               -k[7]], " + \
                        "[         k[6],  k[7]], " + \
                        "[         -k[5], -k[7]]]"

    schema_short1 = "[ [k[5],  k[3]], " + \
                    "[ -k[1], -k[3]], " + \
                    "[         k[3]], " + \
                    "[ -k[6], -k[3]]]"

    schema_short2 = "[[ k[1],  k[7]], " + \
                    "[        -k[7]], " + \
                    "[  k[6],  k[7]], " + \
                    "[ -k[5], -k[7]]]"

    schema_short = "[[ k[5],  k[3]], " + \
                   "[ -k[1], -k[3]], " + \
                   "[         k[3]], " + \
                   "[ -k[6], -k[3]], " + \
                   "[  k[1],  k[7]], " + \
                   "[        -k[7]], " + \
                   "[  k[6],  k[7]], " + \
                   "[ -k[5], -k[7]]]"

    # two_summands_schema = "[ [k[0], k[1], k[4]], [-k[1], -k[3]],\
    #                        [k[2], k[3]], [-k[0], -k[2], -k[4]] ]"
    # two_small_summands_schema = "[[k[3]], [-k[3]],\
    #                             [k[3]], [-k[3]] ]"
    #
    # four_summands_schema = "[[k[3],  k[2],  k[0]],\
    #                         [       -k[2], -k[0]],\
    #                         [        k[1],  k[0]],\
    #                         [-k[3], -k[1], -k[0]]]"
    #
    four_summands_schema = "[[ k[0],  k[1],  k[3]]," + \
                           "[        -k[1], -k[3]]," + \
                           "[         k[2],  k[3]]," + \
                           "[ -k[0], -k[2], -k[3]]]"

    # formula_1 = "[[ k[0],  k[5],  k[3]], " + \
    #             "[        -k[1], -k[3]], " + \
    #             "[         k[2],  k[3]], " + \
    #             "[ -k[0], -k[2], -k[3]]]"
    #
    # formula_2 = "[[ k[4],  k[1],  k[7]], " + \
    #             "[        -k[5], -k[7]], " + \
    #             "[         k[6],  k[7]], " + \
    #             "[ -k[4], -k[6], -k[7]]]"
    #
    # formula_1 = "[[ k[0], k[5],  k[3]], " + \
    #             "[       -k[5], -k[3]], " + \
    #             "[        k[2],  k[3]], " + \
    #             "[-k[4], -k[2], -k[3]]]"
    #
    # formula_2 = "[[ k[4], k[1],  k[7]], " + \
    #             "[       -k[1], -k[7]], " + \
    #             "[        k[6],  k[7]], " + \
    #             "[-k[0], -k[6], -k[7]]]"


def main(arg=None):
    try:
        limit = int(arg[_sage_const_1 ])
    except (IndexError, TypeError):
        limit = None
    conf = Config()
    cable_loop_with_details(conf)


def print_sigma_for_cable(verbose=True, Schemas=None):

    schema_short1 = Schemas.schema_short1
    schema_short2 = Schemas.schema_short2
    schema_short = Schemas.schema_short
    schema_four = Schemas.four_summands_schema

    cable_template = cs.CableTemplate(knot_formula=schema_short)
    cable_template.fill_q_vector()
    q_v = cable_template.q_vector
    print(q_v)
    print(cable_template.cable.knot_description)
    cable1 = cs.CableTemplate(knot_formula=schema_short1,
                              verbose=verbose,
                              q_vector=q_v
                             ).cable
    cable2 = cs.CableTemplate(knot_formula=schema_short2,
                              verbose=verbose,
                              q_vector=q_v
                             ).cable
    cable = cs.CableTemplate(knot_formula=schema_short1,
                              verbose=verbose,
                              q_vector=q_v
                             ).cable

    cable.plot_sigma_for_summands()
    # cable1.plot_sigma_for_summands()
    # cable2.plot_sigma_for_summands()


def cable_loop_with_details(verbose=True):
    # verbose = False
    schema_short1 = Schemas.schema_short1
    schema_short2 = Schemas.schema_short2
    schema_short = Schemas.schema_short
    cable_template = cs.CableTemplate(knot_formula=schema_short)

    list_of_q_vectors = []
    # for el in [2, 3, 5, 7, 11, 13]:
    for el in [_sage_const_2 ]:
        cable_template.fill_q_vector(lowest_number=el)
        q_v = cable_template.q_vector
        print(q_v)
        print(cable_template.cable.knot_description)
        cable1 = cs.CableTemplate(knot_formula=schema_short1,
                                  verbose=verbose,
                                  q_vector=q_v
                                 ).cable
        cable2 = cs.CableTemplate(knot_formula=schema_short2,
                                  verbose=verbose,
                                  q_vector=q_v
                                 ).cable
    #     print("\n")
    #     print(cable1.knot_description)
        is_1 = cable1.is_function_big_for_all_metabolizers(invariant=cs.SIGMA)
        is_2 = cable2.is_function_big_for_all_metabolizers(invariant=cs.SIGMA)
        if is_1 and is_2:
            print("sigma is big for all metabolizers")
        else:
            print("sigma is not big for all metabolizers")
        print("\n" * _sage_const_3 )


def few_cable_without_calc(verbose=False):

    schema_short1 = Schemas.schema_short1
    schema_short2 = Schemas.schema_short2
    schema_short = Schemas.schema_short

    cable_template = cs.CableTemplate(knot_formula=schema_short)

    list_of_q_vectors = []
    for el in [_sage_const_2 , _sage_const_3 , _sage_const_5 , _sage_const_7 , _sage_const_11 , _sage_const_13 ]:
        cable_template.fill_q_vector(lowest_number=el)
        q_v = cable_template.q_vector
        print(q_v)
        print(cable_template.cable.knot_description)
        cable1 = cs.CableTemplate(knot_formula=schema_short1,
                              verbose=verbose,
                              q_vector=q_v
                             ).cable
        cable2 = cs.CableTemplate(knot_formula=schema_short2,
                                  verbose=verbose,
                                  q_vector=q_v
                                 ).cable
        is_1 = cable1.is_function_big_for_all_metabolizers(invariant=sigma)
        is_2 = cable2.is_function_big_for_all_metabolizers(invariant=sigma)
        if is_1 and is_2:
            print("sigma is big for all metabolizers")
        else:
            print("sigma is not big for all metabolizers")
        print("\n" * _sage_const_3 )


def smallest_cable(verbose=True):

    schema_short1 = Schemas.schema_short1
    schema_short2 = Schemas.schema_short2
    schema_short = Schemas.schema_short


    cable_template = cs.CableTemplate(knot_formula=schema_short)
    q_v = cable_template.q_vector
    print(q_v)
    cable1 = cs.CableTemplate(knot_formula=schema_short1,
                              verbose=verbose,
                              q_vector=q_v).cable
    cable2 = cs.CableTemplate(knot_formula=schema_short2,
                              verbose=verbose,
                              q_vector=q_v).cable
    cable1.is_function_big_for_all_metabolizers(invariant=sigma)
    cable2.is_function_big_for_all_metabolizers(invariant=sigma)


def plot_many_untwisted_signature_functions(range_tuple=(_sage_const_1 , _sage_const_10 )):
    P = Primes()
    for i in range(*range_tuple):
        q = P.unrank(i)
        a = cs.CableSummand.get_untwisted_signature_function(q=q)
        a.plot()


if __name__ == '__main__':
    if '__file__' in globals():
        # skiped in interactive mode as __file__ is not defined
        main(sys.argv)
    else:
        pass
        # main()


# formula_long = "[[k[0], k[5], k[3]], " + \
#                   "[-k[5], -k[3]], " + \
#                    "[k[2], k[3]], " + \
#             "[-k[4], -k[2], -k[3]]" + \
#             "[k[4], k[1], k[7]], " + \
#                   "[-k[1], -k[7]], " + \
#                    "[k[6], k[7]], " + \
#             "[-k[0], -k[6], -k[7]]]"
#
#
# formula_1 = "[[k[0], k[5], k[3]], " + \
#                   "[-k[1], -k[3]], " + \
#                          "[ k[3]], " + \
#             "[-k[4], -k[6], -k[3]]]"
#
# formula_2 = "[[k[4], k[1], k[7]], " + \
#                        "[ -k[7]], " + \
#                    "[k[6], k[7]], " + \
#             "[-k[0], -k[5], -k[7]]]"
#
#

